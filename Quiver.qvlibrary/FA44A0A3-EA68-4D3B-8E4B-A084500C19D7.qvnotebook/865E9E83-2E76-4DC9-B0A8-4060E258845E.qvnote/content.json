{
  "title": "10 January // Lecture 1",
  "cells": [
    {
      "type": "markdown",
      "data": "Jan Prins\n[Homepage](https://www.cs.unc.edu/~prins/Classes/520)\n\nReading for Tues. 15 Jan: PLPJ Ch. 1\n\nExample: program => compiler (translation to machine code) => linker (links in machine code library) => executable\n\nResponsibilities of the C compiler:\n- Recognize legal source programs\n- Issue appropriate errors for invalid programs\n- Generate correct (and efficient) machine code for valid programs\n\nTranslation:\n- Hope to preserve meaning!\n- \"Syntax-directed translation\"\n    - meaning is conveyed using the structure of the sentences\n- Steps:\n    1. decode the \"structure\" fromt the input character stream\n    2. match source language concepts to target language concepts\n    3. encode target structure into output\n\nContext!\nExecution of program: for e.g. Java (possibly python?), the machine instructions (`.class` files) are for the JVM, an abstract machine\n\n*Compiler*: Translates a program from one representation to another\n*Interpreter*: Executes the computation specified by a program\n\nDifferent execution strategies (relative proportions of compilation & interpretation)\nThis always comes with tradeoffs\n\nWhy study?\n- What can be translated?\n- What can/should be avoided?\n    - Particularly those that interfere with correctness/efficiency\n- What features are unnecessary?\n- Understand compiler errors/warnings\n- IDEs, syntax highlighting, and autocompletion\n- Debuggers (capabilities, limitations)\n- Linkers and Loaders\n- JITters\n- Performance\n- Skills:\n    - Parse/execute input (DB, CLI, GUI)\n    - Flexible tools are \"programmable\"\n    - Performance optimization\n- Pedagogy:\n    - Automata\n    - Programming language design and implementation\n    - Data structures and algorithms\n    - Machine organization\n    - Software engineering principles\n- \"META\"\n\nLanguage Evolution: Java Generics\n\n(Aside: Administrivia)"
    }
  ]
}