{
  "title": "Takehome Final",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "1. We are given the root of a tree $r$; each node $v$ has the following values: $Parent, Children, Value, PrHeads$ as explained in the problem.\nSome initial conventions:\n    - $\\forall f: \\sum_{i \\in \\emptyset}{f(i)} = 0$;\n    - $v \\in^* u$ means $v$ is in a subtree of $u$;\n    - $\\forall v \\in^* r : v.Value \\ge 0$ (note here that $r.Value$ is included as well);\n    - $Coin(v)$ is a function returning $c \\in \\{H,T\\}$, the value of the coin flip at $v$;\n    - We can collect a coin $v$ if:\n        - $Coin(v) = H$; and\n        - $\\neg (\\exists u \\in Collected : v \\in^* u)$ where $Collected$ is a set of collected coins\n        \n(a) We know all flip outcomes at the start; that is, $\\forall v \\in^* r : Coin(v)$ is known.\n\nWith this constraint, the decision problem becomes rather simple: we cannot take coins that are tails, so we take the best we can from their children. For coins that are heads, we take the maximum of that coin's value and the sum of all its subtrees values (for, if we don't take a heads-coin, we can take all of the coins in its subtree). We note that we have assumed all values are positive; if negatives were permissible, the algorithm would simply exclude it from the sum and the choice.\n\nWe define the function $Value(v)$ to capture this choice:\nFirst, let $ValueSubtree(v) = \\sum_{c \\in v.Children}{Value(c)}$. Then\\[\n    Value(v) = \\begin{cases}\n        ValueSubtree(v), & \\text{if $Coin(v) = T$} \\\\\n        \\max\\left(v.Value, ValueSubtree(v)\\right), & \\text{otherwise}\n    \\end{cases}\n\\]Then we seek the value $Value(r)$.\n\nFor performant implementation (that is, to avoid deep recursion), we can compute this bottom up, starting with the leaves, memoizing (tabulating) the results as we go. Then $ValueSubtree$ can rely on the memoized values and compute $Value(child)$ in constant time.\n\n(b) We must choose based only on expected values of coins; that is, $\\forall v \\in^* r : Coin(v)$ is unknown during the entirety of the algorithm.\n\nHere, too, the decision is simple: we prioritize expected value over actual value, taking either the current coin or those in its subtree. We define $E(v)$ to be the maximum expected value at a node.\\[\n    E(v) = \\max\\left(v.Value \\cdot v.PrHeads, \\sum_{c \\in v.Children}{E(c)}\\right)\n\\]Then we seek the value $E(r)$.\n\nAs above, we eliminate negatives from the summations and compute in bottom-up, memoized fashion to save ourselves the deep recursion.\n\n(c) We flip each coin only when we reach it, and must decide on the spot.\n\nThe decision here combines aspects of the previous problems. When we reach any node, we flip the coin to get $Coin(v)$. If it's tails, we clearly don't take it, and move on to each of the children. If the coin is heads, then we can take either it (for a value of $v.Value$), or try each of the children. The children have an expected value of $\\sum_{c \\in v.Children}{E(c)}$ (with $E$ from 1.b), and we thus know how to make our decision.\n\nWe define $W(v)$:\\[\n    W(v) = \\begin{cases}\n        \\sum_{c \\in v.Children}{W(c)}, & \\text{if $Coin(v) = T$ or $v.Value \\lt \\sum_{c \\in v.Children}{E(c)}$} \\\\\n        v.Value, & \\text{otherwise} \\\\\n    \\end{cases}\n\\]Then we seek $W(r)$; we can pre-compute $E$ as above, but then must compute $W(r)$ on-the-fly. Explained recursively here, an iterative approach is possible (rather like a Depth-First search).\n\nWe note that in all of these problems, extra bookkeeping would allow recovery of the choices made (read: coins selected) to arrive at the maximum value.\n\n(d) We wish to prove that $\\forall h \\ge 1$ a tree $r$ with height $h$ and known flips has optimal/maximal value given by the algorithm $Value(r)$ in 1.a; that is, no other way to choose coins could increase the value under the condition of known flips.\n\nWe prove this by induction on $h$.\n\nBase cases:\n$h=1$: The \"tree\" $r$ is a leaf. The maximum value can only be $r.Value$ or $0$, depending on the coin flip. Not choosing $r.Value$ when the coin is heads would give $0$ when we can get $r.Value$; heads is the only way to get $r.Value$, so any other flip gives $0$. We note then that $ValueSubtree(r) = 0$ since $r.Children$ is an empty set, and is the result of the algorithm when the flip is tails (not heads). When the flip is heads, we choose $\\max(r.Value, 0)$ (note that this handles negative values by not choosing them, though we assume for this proof that values are positive). Thus in both cases we choose the correct values.\n\n$h=2$ (probably unnecessary): Now the tree $r$ has only leaves for children. We know the maximum value for each of those is correctly computed by $Value$. What is the maximum value for $r$? Does $Value(r)$ capture it? If $r$ comes up tails, choosing all of the children yields $ValueSubtree(r)$, and choosing any proper subset of them yields a value less than this (so it is sub-optimal).\n\nIf instead $r$ comes up heads, then the maximum possible values are when we choose $r$ or don't: choosing $r$ has value $r.Value$; not choosing it has maximum value $ValueSubtree(r)$ (since it is equivalent to $r$ being tails). We choose based on the maximum of these two values.\n\nThis is precisely what is given if we substitue $r$ for $v$ in $Value$ and expand:\\[\n    Value(r) = \\begin{cases}\n        ValueSubtree(r) = \\sum_{c \\in r.Children}{c.Value}, & \\text{if $Coin(r) = T$} \\\\\n        \\max\\left(r.Value, ValueSubtree(r)\\right), & \\text{otherwise}\n    \\end{cases}\n\\]\n\nInduction hypothesis: assume $\\forall 1 \\le k \\lt h$ that $\\forall$ trees $r$ of height $k$, $Value(r)$ correctly computes the optimal/maximal value under the given conditions.\n\nInduction: Now, take a tree $r$ of height $h$. Notice that all of its subtrees have height $\\lt h$, and so $Value$ computes their optimal value.\n\nIn the case where $r$ is tails: we cannot collect $r$, so we move on to each of the sub-trees. But we already know their optimal values! So we sum these; summing a proper subset would result in a smaller, sub-optimal value (since all the values are positive). But this is precisely the expansion $ValueSubtree(r) = \\sum_{c \\in r.Children}{Value(c)}$ given in $Value$.\n\nIn the case where $r$ is heads: we either take $r$, or we don't. Not taking it is equivalent to $r$ being tails, with value as stated above. Taking it has value $r.Value$, since we stop collecting subtrees at this point. The maximum value of the tree is then the maximum of these values—they are the only two choices we can make. But this precisely given by $\\max(r.Value, ValueSubtree(r))$ in $Value$.\n\nThus $Value$ correctly decides the maximal value of a tree of height $h$ (assuming the induction hypothesis holds).\n\nBy strong induction, $\\forall h \\ge 1$ a tree $r$ with height $h$ has optimal value given $Value(r)$; choosing coins in any other way would result in a smaller value. $\\diamond$\n\n2. We now consider a DAG of nodes with coins of value $v.Value$. We may collect any coin, provided it is the first collected on some path from the root $r$. Determining the maximum value of coins collected in the DAG becomes NP-Hard.\n\nWe can use it to solve vertex cover—given a graph $G=(V,E)$, and integer $k$, we construct the following DAG:\n- A root node $r$ has $r.Value=0$\n- $\\forall v \\in V$ we construct a child $u$ of $r$ with $u.Value=1$\n- $\\forall (u,v) \\in E$ we construct a child $e$ of the nodes $u,v$ representing the vertices of the edge with $e.Value=3$\n\nWe show that there exists a vertex cover of size $\\le k \\iff$ it is possible to collect coins in the given DAG of total value $\\ge 3\\mid{E}\\mid + \\mid{V}\\mid - k$.\n\nAssume that there is a way to collect coins in the DAG of value exactly $n = 3\\mid{E}\\mid + \\mid{V}\\mid - k$. Then we must have collected one coin for every edge-gadget, and one coin for $\\mid{V}\\mid - k$ vertex-gadgets. (This is so due to the construction of the graph; if it were possible to not select an edge-gadget, then we would need to select an additional 3 vertex-gadgets—but that eliminates even more edge-gagdets from our selection, and if it doesn't, then we were capable of selecting those vertex-gadgets $\\textit{anyways}$.) That is, there are $k$ coins $\\textit{not}$ selected. But now we can construct a vertex cover in the original graph as follows: the $k$ unselected vertex-gadgets give us $k$ vertices to select in the original graph, and we know that they cover all edges because each edge-gadget was collected in the DAG, and therefore there was a path from an unselected vertex-gadget to the edge-gadget, meaning the vertex covers that edge. Now, if there is a way to collect more than $n$ coins, than we have less than $k$ unselected vertices forming our vertex cover. This shows the if direction.\n\nFor the only-if, assume that there is a vertex cover of size $k$. Then we construct the DAG as described. We now pick each edge-gadget, for a total value of $3\\mid{E}\\mid$. Note that if we selected all $k$ vertex-gadgets for the vertices in the cover, we would be unable to select $\\textit{any}$ of the edge-gadgets, because the covering vertex-gadgets are on a path from the root to each of the edges. So we select all the vertex-gadgets for vertices $\\textit{not}$ in the cover, for a value of $\\mid{V}\\mid-k$. This gives a total value of $n$ as above. Now, if the vertex cover is smaller than $k$, than we have more than $\\mid{V}\\mid-k$ vertices not in the cover, allowing us to choose that many in our DAG, increasing our value to $\\gt n$. This shows the only-if direction.\n\n$\\diamond$"
    }
  ]
}