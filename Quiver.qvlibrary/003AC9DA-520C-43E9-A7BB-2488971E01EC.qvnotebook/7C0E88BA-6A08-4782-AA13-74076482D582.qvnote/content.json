{
  "title": "Graph Problems 1-3",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "Q1. Certifying bipartite graph tester\n\nA graph $G = (V,E)$ is bipartite $\\iff$ we can color every vertex $v \\in V$ red or blue so every edge touches both colors.\n\nA certifying bipartite tester can certify \"$G$ is bipartite\" with a two-coloring of $V$, which the caller can check in $\\Theta(\\mid E \\mid)$ time, or can certify the negation with an odd-length cycle, which the caller can check using edges from $E$.\n\nModify BFS or DFS to create a certifying bipartite graph tester that runs $O(\\mid V \\mid + \\mid E \\mid)$ time.\n\nA: The essence of the modifications to BFS are twofold:\n\n1. Rather than a white-grey-black coloring, note that if the graph is bipartite, the start node must be one of two colors (red or blue), and it determines the color of all other nodes in the graph (assuming, of course, that the graph is not disconnected). So we simply color each node based on the color of its neighbor node and return the graph.\n\nIf $G$ contains separate, distinct, connected components, we can color each one individually and union the results, with failure in any of them failing the entire result.\n\n2. If there is a cycle, we will find it when we attempt to color one node with two different colors. We thus add an additional \"color\" to the graph: the intended color of the node. Before a node is enqueued, its intended color is set. We fully color a node when we dequeue it later. If, in processing neighbors, we find that we intend to color a node twice differently, we fail with a cycle. We maintain previous pointers which we can follow back to a common source, and return a set containing the cycle.\n\nThe modifications all take constant time, except the cycle computation, which takes $O(\\mid V \\mid + \\mid E \\mid)$ time to trace back through. Thus the entire computation is in $O(\\mid V \\mid + \\mid E \\mid)$ time."
    },
    {
      "type": "code",
      "language": "python",
      "data": "Bipartite_BFS(G,s):\n    for each vertex v in G.V - {s}:\n        v.color = NIL\n        v.intended_color = NIL\n        v.prev = NIL\n    s.color = RED\n    s.intended_color = NIL\n    s.prev = NIL\n    Q = {}\n    Enqueue(Q,s)\n    while Q != {}:\n        u = Dequeue(Q)\n        if u.prev != NIL:\n            # color a node\n            u.color = u.intended_color\n            u.intended_color = NIL\n        nextcolor = nextcolor(u.color)\n        for each v in G.Adj[u]:\n            if v.intended_color == u.color:\n                # cycle detected\n                return Cycle(G,u,v)\n            if v.color == NIL and v.intended_color == NIL:\n                v.intended_color = nextcolor\n                v.prev = u\n                Enqueue(Q,v)\n    return G\n    \nnextcolor(color):\n        if color == RED:\n            return BLUE\n        else:\n            return RED\n\nCycle(G,u,v):\n    cycle = {u,v}\n    prevs = {u.prev, v.prev}\n    while prevs != {}:\n        p = Dequeue(prevs)\n        if p in cycle:\n            # found the common node\n            assert cycle.length % 2 == 1\n            return cycle\n        else:\n            Add(cycle, p)\n            if p.prev != NIL:\n                Enqueue(prevs, p.prev)\n    Error(\"shouldn't get here\")"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "Q2. Certifying connected components\n\nA graph $G = (V,E)$ can be partitioned into connected components, sets of vertices that can be joined by a path.\n\nTo certify connected components, give each vertex a component number $c_u$ in addition to its tree number $t_u$. For each $u$, check that $\\forall v \\in N(u) : c_v = c_u$ and that, with one exception per component, each vertex has a neighbor lower tree number.\n\nModify DFS to assign component numbers, and show that discovery times $u.d$ can serve as tree numbers.\n\nA: We note first that the discovery times $u.d$ serve as tree numbers because they distinguish between nodes at the same level of the \"tree\" (quoted here because the \"tree\" may contain cycles). There can only be one root, the first node discovered in the \"tree\" ($=$ component), and DFS guarantees that each subsequently discovered node will be deeper than the root. Thus each node gets assigned a number such that, for any component, all nodes except the root have at least one neighbor with lower tree number (one of the nodes discovered prior). This holds even in the case of a single-node component (itself the exception).\n\nNow, for a modification to assign component numbers: we note that the DFS presented uses the recursion stack to maintain a stack. However, there is an \"outermost\" call to the visitation function; namely, that which finds any node not already visited by a DFS of a one component and starts DFS there. But DFS of any single node in a component will trace the entire component, so this outermost call must find a node not in the component, or none at all! Thus we can use a global variable (or function parameter) to track the component number that should be assigned to each node in an iteration of a DFS. In the modified version, we present $DFS\\_VISIT$ as an inner function to render more clear the access to variables in the outer scope."
    },
    {
      "type": "code",
      "language": "python",
      "data": "DFS(G):\n    u.f = time\n    for each vertex u in G.V:\n        u.color = WHITE\n        u.pi = NIL\n    time = 0\n    component = 0\n    for each vertex u in G.V:\n        if u.color == WHITE:\n            DFS_VISIT(G,u)\n            component++\n\n    DFS_VISIT(G,u):\n        time++\n        u.d = time\n        u.color = GRAY\n        u.component = component\n        for each v in G.Adj[u]:\n            if v.color == WHITE:\n                v.pi = u\n                DFS_VISIT(G,v)\n        u.color = BLACK\n        time++"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "Q3. Certified topo sort\n\nGiven an $n$-vertex DAG $G = (V,E)$, a topo sort numbers vertices $V=\\{v_1, \\dots, v_n\\}$ so that $(v_j,v_i) \\in E \\implies j \\gt i$.\n\nDeleting the first two lines of $DFS\\_VISIT$ produces finishing times $1 \\dots n$ that can tree numbers. Make another modification to detect and halt if there is a directed cycle.\n\nA: We note that if we find a gray, reachable vertex $v$ from our current position in the search $u$, then we are in a cycle, since otherwise we would finish without finding a previously-visited (but not finished) node, and pop back up the stack, coloring nodes black. That is, since $v$ is not black, the depth of its subgraph was never finished, and because it isn't white, it is part of this DFS. So it must be a cycle.\n\nNote that, as asked, we detect and halt if there is a directed cycle. We return no other information to certify said cycle."
    },
    {
      "type": "code",
      "language": "python",
      "data": "DFS(G):\n    u.f = time\n    for each vertex u in G.V:\n        u.color = WHITE\n        u.pi = NIL\n    time = 0\n    for each vertex u in G.V:\n        if u.color == WHITE:\n            DFS_VISIT(G,u)\n\n    DFS_VISIT(G,u):\n        u.color = GRAY\n        for each v in G.Adj[u]:\n            if v.color == GRAY:\n                halt(\"Cycle\")\n            if v.color == WHITE:\n                v.pi = u\n                DFS_VISIT(G,v)\n        u.color = BLACK\n        time++"
    }
  ]
}