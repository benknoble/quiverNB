{
  "title": "Homework 5",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "Q1. Randomized QuickSelect has input $A[1 \\dots n], i$ and returns the $i$th smallest element of $A$. We will show it runs in $O(n)$ time.\n\nLet $z_1, \\dots z_n$ be the sorted list of elements in $A$, and $X_{j,k}$ be the indicator value of $(j \\lt k \\land$ we compare $z_j$ and $z_k)$.\n\nWe seek then $\\sum_{1 \\le j \\lt k \\le n}E[X_{j,k}]$\n\n\\begin{equation}\n    E[X_{j,k}] = \\Pr(X_{j,k} = 1) = \\begin{cases}\n        \\frac{2}{k-i+1}, & i \\lt j \\lt k & (1)\\\\\n        \\frac{2}{k-j+1}, & j \\le i \\le k & (2)\\\\\n        \\frac{2}{i-j+1}, & j \\lt k \\lt i & (3)\\\\\n    \\end{cases}\n\\end{equation}\n\nFor case (1), we have $\\sum_{i \\lt j \\lt k}\\frac{2}{k-i+1} = \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}\\frac{2}{k-i+1} \\\\\n= \\sum_{i=1}^{k-1}{(k-i)\\frac{2}{k-i+1}} \\le 2(k-1) \\in O(n)$\nsince $k-i+1 \\le k$ and $k$ is bounded by $n$.\n\nFor case (2), we have $\\sum_{j \\le i \\le k}\\frac{2}{k-j+1} = \\sum_{j=1}^{k-1}\\sum_{i=j+1}^{k}\\frac{2}{k-j+1} \\\\ \n= \\sum_{j=1}^{k-1}(k-j)\\frac{2}{k-j+1} \\le \\sum_{j=1}^{k-1} 2 \\le 2(k-1) \\in O(n)$\n\nCase (3) is nearly identical.\n\nQ2. IP addresses\n\n(a) There are $255^4 = (2^8-1)^4$ distinct IP addresses.\n(b) The max value of your hash function is $2550$, and the linear combination of the sections of the IP can likely be used to generate any value in $[0,2550]$. So, $2550$ slots.\n(c) $A + B^2 + C^3 + D^4 \\mod 104729$\n(d) Assuming the hash function is randomly uniform, the average size of a chain would be the load factor $\\alpha = \\frac{n}{m} =\\frac{50000}{104,279} \\approx 0.479 \\approx 0.5$\n(e) The biggest issue is that the code does not, as described, search the hash table and only add if not present: in fact, it adds an excessive number of duplicates (consider that 1,000,000 elements randomly selected from a length of 50,000 would have an average number of duplicates of 20 per element). Since we can expect to average 20 duplicates per element, a sizeable of buckets will each contain all the duplicates of two elements when there is a collision; this yields about 40 elements.\n\nThe peak at 20 might be expected since the load factor of 1,000,000 elements distributed accross approximately 100,000 buckets is 10. Each containing two would suggest 20 per bucket.\n\nQ3. Open address hash table\n\n(a) Inserting $n$ entries into $m$ slots takes $\\sum_{i=1}^n \\frac{1}{1-\\alpha_i}$ time, where $\\alpha_i = \\frac{i-1}{m}$ denotes the load factor prior to inserting the $i$th element. That is, we have $\\frac{1}{1-\\alpha_i} = \\frac{m}{m-i+1}$, and the sum $m\\sum\\frac{1}{m-i+1} = m(\\frac{1}{m} + \\frac{1}{m+1} + \\dots + \\frac{1}{n+1})$. Remembering that $n \\le m$, we see that the expanded sum of fractions is equivalent to $(1 + \\frac{1}{2} + \\dots + \\frac{1}{m}) - (1 + \\frac{1}{2} + \\dots + \\frac{1}{n}) = H_m - H_{m-n}$\n\nThus the cost is $m(H_m - H_{m-n})$.\n\n(b) Quadrupling tables. We know the hash table is full when we have insert $m$ entries. At this point, we create a table of size $4m$, reinsert our $m$ elements at cost $O(4m)$ (time to resize table). Then we attempt to insert the remaining $n-m$ entries.\n\nHowever, it would take at least $\\frac{3m}{4}$ more $O(1)$ inserts before we pay the $O(4m)$ cost again, so we can imagine each of those getting a portion of the cost, for an amortized cost of $O(\\frac{4m}{.75m}) = O(\\frac{16}{3}) = O(1)$. The total is $O(n)$.\n\n(c) Doubling half-full tables. Once again, at the doubling stage we spend $O(2m)$ time, but it takes at least $\\frac{m}{2}$ more inserts before we pay the cost. Spreading it out, we get $O(\\frac{2m}{.5m}) = O(1)$. The total is once again $O(1)$.\n\n(d) While, at first glance from the asymptotic bounds, they appear fairly equal, the hidden constant from part (b) is much higher. Thus (c) requires less total work."
    }
  ]
}