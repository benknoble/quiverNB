{
  "title": "Takehome Midterm 1",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "Q1. The recurrence given is $T(n) = 4T(\\lfloor \\frac{n}{2} \\rfloor + 2) + n$.\nWe have bases cases $\\forall n \\le 5, T(n) = 1$\n\n(a) I list below the first 20 values of the above recurrence, computed from the code listed. There are two methods of computation: direct recursion and memoized list."
    },
    {
      "type": "code",
      "language": "python",
      "data": "#! /usr/bin/env python3\n\nimport math\n\n_ts = [1 for _ in range(5)]\n\n\ndef recurrence(n):\n    if n <= 5: return 1\n    else: return 4 * recurrence(math.floor(n / 2) + 2) + n\n\n\ndef recurrence2(n):\n    def index(n): return n - 1\n    if 0 <= index(n) < len(_ts): return _ts[index(n)]\n    _ts.insert(index(n), 4 * _ts[index(math.floor(n/2) + 2)] + n)\n    return _ts[index(n)]\n\n\ndef main():\n    ts = map(recurrence, range(1, 21))\n    ts2 = map(recurrence2, range(1, 21))\n    print(' n | T(n) | T_2(n)')\n    for (i, (t1, t2)) in enumerate(zip(ts, ts2)):\n        print('%2d | %4d | %4d' % (i+1, t2, t2))\n\n\nif __name__ == '__main__':\n    main()\n\n#>>> import recurrence\n#>>> recurrence.main()\n'''\n n | T(n) | T_2(n)\n 1 |    1 |    1\n 2 |    1 |    1\n 3 |    1 |    1\n 4 |    1 |    1\n 5 |    1 |    1\n 6 |   10 |   10\n 7 |   11 |   11\n 8 |   48 |   48\n 9 |   49 |   49\n10 |   54 |   54\n11 |   55 |   55\n12 |  204 |  204\n13 |  205 |  205\n14 |  210 |  210\n15 |  211 |  211\n16 |  232 |  232\n17 |  233 |  233\n18 |  238 |  238\n19 |  239 |  239\n20 |  836 |  836\n'''"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "(a1) $T(3)$ and $T(4)$ must be base cases becase the recurrence definition gives\n$$T(3) = 4T(\\lfloor\\frac{3}{2}\\rfloor + 2) + 3 = 4T(3) + 3$$\n$$T(4) = 4T(\\lfloor\\frac{4}{2}\\rfloor + 2) + 4 = 4T(4) + 4$$\neach of which is defined in terms of itself, giving $3T(3) + 3 = 0$ and $3T(4) + 4 = 0$, neither of which have positive solutions of $T(i)$, which we require.\n\nAdditionally, $T(2)$ depends on $T(3)$.\n\n(a2) The base case $T(5)=1$ affects subsequent values computed by the recursive rule because $T(6)$ depends on $T(5)$ and all $T(i), i \\gt 6$ depend on $T(6)$ or larger, thus depending on $T(5)$. Of course, if we compute $T(5)$ recursively (that is, removing it from the base case list), everything depends on $T(4)$.\n\n(b) The proof noted that $c \\ge \\frac{7}{4}$ gives $\\forall n \\ge 6 : T(n) \\le cn^2 - 6n$. Taking $c = \\frac{7}{4}$, we have\n- $T(4) = 1 \\le \\frac{7}{4} \\cdot 4^2 - 6(4) = 28 - 24 = 4$\n- $T(5) = 1 \\le \\frac{7}{4} \\cdot 5^2 - 6(5) = 13.75$\n\nHowever, $T(1) = 1 \\gt \\frac{7}{4} \\cdot 1^2 - 6(1) = \\frac{7-24}{4} = \\frac{-17}{4}$\n\nI detected the following errors in the proof.\n- In the application of the induction hypothesis, the $c$ is pulled out and multiplied by the entire expansion of $(\\frac{n}{2} + n)^2 - 6(\\frac{n}{2} + 2)$, when it shoudn't have been. This leads to erroneous results\n- The conclusion is that $cn^2 - 4cn - 32c + n \\le cn^2 - 6$, so there's a missing $n$ (the typo).\n- Finally, from the corrected results, $c \\ge 7$ and $c \\le 3$, which simply isn't possible. Thus the premise is false.\n\n(c) We shall prove $\\exists c \\gt 0, d, e : \\forall n \\ge 5 : T(n) \\le cn^2 - dn + e$ by induction on $n$.\nBase case: $T(5) = 1 \\le 25c - 5d + e$, giving our first constraint.\nNow we assume $\\forall 5 \\le k \\lt n : T(k) \\le ck^2 - dn + e$.\nThen $T(n) = 4T(\\frac{n}{2} + 2) + n$ (note the dropped floors)\n$\\le 4\\left[c\\left(\\frac{n}{2} + 2\\right)^2 - d\\left(\\frac{n}{2} + 2\\right) + e\\right] + n$ (since $\\forall n \\ge 4 : \\frac{n}{2} + 2 \\le n$)\n$= cn^2 - 8cn + 16c - 2dn - 8d + 4e + n$\n$= cn^2 - dn + e + n(8c - d + 1) + (16c - 8d + 3e)$\n$\\le cn^2 - dn + e$ when $8c - d + 1 \\le 0 \\land 16c - 8d + 3e \\le 0$.\n\nTo satisfy this, we choose $d = 8c + 1 \\ge 8c + 1 \\ge 0$;\nthen $e = \\frac{48c + 8}{3} \\le \\frac{8d - 16c}{3}$;\nthen $c = \\frac{10}{3} \\ge \\frac{1 + 5d - e}{25}$.\n\nNow, all of our constraints are satisfied:\n$1 \\le 25c - 5d + e$\n$\\land 8c - d + 1 \\le 0$\n$\\land 16c - 8d + 3e \\le 0$\n\n$\\therefore \\forall n \\ge 5 : T(n) \\le cn^2 - dn + e \\diamond$.\n\nFor the ponderable: note that each term $n_i$ in the sequence is precisely $\\frac{n_{i-1}}{2} + 2$. Therfore, if for $i=1$ the formula determined gives exactly $T(n)$, it will for all in the sequence.\n\nQ2. We have the denominations $D[1\\dots8] = [1,4,7,13,28,52,91,365]$\n\n(a) Take the value $455$. The greedy algorithm gives $455 = 365 + 52 + 28 + 7 + 3(1)$, using $7$ bills. But $455 = 5\\cdot92$, using only $5$ bills.\n\n(b) We state first the input and output of the algorithm $B(k,D)$:\n\nInput:\n- $D$, a set of denominations (sorted in ascending order--we also assume the denomination $1$ is present, as otherwise we run the risk of not all values being possible; for DreamDollars this holds);\n- $k$, an amount\n\nOutput:\n- $B(k,D)$, the minimum number of bills needed to make $k$ DreamDollars using denominations in $D$\n\nNow, note that when $k$ is one of the elements of $D$, the answer is just $1$.\nFurther, note that when we have the answers to $B(k-i)$ for all $i \\in D$, we can add 1 to the minimum of these values (to represent adding denomination $i$ to $k-i$, such that the number of bills increases by 1).\n\nThen \\begin{equation}\n    B(k,D) = \\begin{cases}\n        1, & \\text{if $k \\in D$}.\\\\\n        \\min\\limits_{i \\in D \\land i \\le k}\\left[B(k-i,D)\\right] + 1, & k \\not\\in D.\n    \\end{cases}\n\\end{equation}\n\nNB implemented na√Øvely, the computational runtime grows exponentially in the magnitude of $D$.\n\n(c) Let us refine this further, to avoid exponential complexity and overlapping subproblems being re-computed. Let $D_i$ be $D[1 \\dots i] \\subseteq D$, the first $i$ denominations of $D$ ($i \\le |D| = n$). Then we consider the subproblems as the minimum number of bills required to make the amount $r$ with $D_i$ denominations; we denote this $B(r,D_i)$. We then seek $B(k,D_n)$.\n\nWe'd like to refine the recurrence above to take advantage of the new information we have. Note that if $D[i] = r$, $B(r, D_i) = 1$. Further, since $D[1] = 1$, $B(r, D_1) = r$. Finally, we have two cases to consider:\n- the denomination $D[i] \\gt r$: then we obviously cannot include it or any other denominations in our solution, so the answer must be $B(r, D_{i-1})$\n- the denomination $D[i] \\lt r$: then either we do include it, or we don't. Not including it would be the same as $B(r, D_{i-1})$. Including it would be $1 + B(r-D[i], D_i)$. We take the min over these two values.\n\nThen \\begin{equation}\n    B(r,D_i) = \\begin{cases}\n        r, & i=1\\\\\n        1, & r = D[i]\\\\\n        B(r, D_{i-1}), & D[i] \\gt r\\\\\n        \\min(B(r, D_{i-1}), 1 + B(r-D[i], D_i)), & D[i] \\lt r\n    \\end{cases}\n\\end{equation}\n\nAnd now we can create a table $m$ of dimension $k \\times n$ and fill it by looping over $(j,i)$ pairs in $\\mathbb{N}_k \\times \\mathbb{N}_n$, computing $B(j,D_i)$ from $m[j][i]$. We handle the $i=1$ base case by filling the section $m[j][1] = j$ for all $j$ first. The computational complexity in time is $O(kn)$, since that is the size of the table and each iteration of the loop depends on at most 2 previously computed subproblems, thus each iteration takes constant time.\n\nWe then note that $B(k, D_n) = m[k][n]$."
    }
  ]
}