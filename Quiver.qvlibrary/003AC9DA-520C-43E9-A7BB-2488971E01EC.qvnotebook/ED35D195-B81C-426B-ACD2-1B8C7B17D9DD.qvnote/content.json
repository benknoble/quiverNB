{
  "title": "Homework 2",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "1. Negate the following statements. Responses must start with un-negated quantifiers.\n\n(a) Any green pyramid is smallest.\n\nI choose to interpret this as\n$$\\forall x : x.green \\implies (\\forall y : y \\neq x \\implies size(x) \\lt size(y))$$\nThus the negation is\n$$\\exists x : \\neg (x.green \\implies (\\forall y : y \\neq x \\implies size(x) \\lt size(y)))$$\n$$ \\equiv \\exists x : \\neg (\\neg x.green \\lor (\\forall y : (y = x) \\lor (size(x) \\lt size(y))) $$\n$$ \\equiv \\exists x : x.green \\land (\\exists y : y \\neq x \\land size(x) \\ge size(y)) $$\n\nThis is (approximately) the statment that there exists a pyramid that is both green and bigger than another pyramid.\n\n(b) $\\exists x : x.small \\land x.green$\n\nThe negation: $\\forall x : \\neg (x.small \\land x.green) \\equiv \\forall x : \\neg x.small \\lor \\neg x.green$\n\n(c) $\\forall x,y : (size(x) \\gt size(y)) \\implies \\neg x.green$\n\nThe negation: $\\exists x,y : \\neg ((size(x) \\gt size(y)) \\implies \\neg x.green) \\equiv \\exists x,y : (size(x) \\gt size(y)) \\land x.green$\n\n(d) $\\forall x,y : (size(x) \\gt size(y)) \\implies y.green$\n\nThe negation: $\\exists x,y : \\neg ((size(x) \\gt size(y)) \\implies y.green) \\equiv \\exists x,y : (size(x) \\gt size(y)) \\land \\neg y.green$\n\n(e) $\\exists x,y : (size(x) \\gt size(y)) \\implies \\neg x.green$\n\nThe negation: $\\forall x,y : \\neg ((size(x) \\gt size(y)) \\implies \\neg x.green) \\equiv \\forall x,y : (size(x) \\gt size(y)) \\land x.green$\n\n(f) Some pyramid is pointing at a pyramid of the same color.\n\nI choose to interpret this as\n$$\\exists x,y : points(x,y) \\land color(x) = color(y)$$\nThus the negation is\n$$\\forall x,y : \\neg (points(x,y) \\land color(x) = color(y))$$\n$$ \\equiv \\forall x,y : \\neg points(x,y) \\lor color(x) \\neq color(y)$$\n$$ \\equiv \\forall x,y : points(x,y) \\implies color(x) \\neq color(y)$$\n\nThis is (approximately) the statement that any pyramid which points at another must be of different color than the pyramid at which it points.\n\n(g) $\\exists x,y : color(x) = color(y) \\land points(x,y)$\n\nThe negation: $\\forall x,y : color(x) \\neq color(y) \\lor \\neg points(x,y) \\equiv \\forall x,y : color(x) = color(y) \\implies \\neg points(x,y)$\n\n(h) $\\exists x : \\forall y : points(x,y) \\implies color(x) = color(y)$\n\nThe negation: $\\forall x : \\exists y : points(x,y) \\land color(x) \\neq color(y)$\n\n(i) Every blue pyramid is touching a large pyramid\n\nI choose the interpretation\n$$\\forall x : x.blue \\implies \\exists y : y.large \\land touch(x,y)$$\n\nThus the negation is\n$$\\exists x : x.blue \\land \\forall y : \\neg y.large \\lor \\neg touch(x,y)$$\n$$ \\equiv \\exists x : x.blue \\land \\forall y : y.large \\implies \\neg touch(x,y)$$\n\nThis is (approximately) the statement that there is a blue pyramid not touching a large pyramid.\n\n(j) $\\forall x : \\exists y : x.blue \\implies y.small \\land touch(x,y)$\n\nThe negation: $\\exists x : \\forall y : x.blue \\land y.small \\implies \\neg touch(x,y)$\n\n(k) $\\exists y : \\forall x : x.blue \\implies y.small \\land touch(x,y)$\n\nThe negation: $\\forall y : \\exists x : x.blue \\land y.small \\implies \\neg touch(x,y)$\n\n(l) $\\forall x : x.blue \\implies \\exists y : y.large \\land touch(x,y)$\n\nThe negation is given in (i) above $\\diamond$.\n\n2. $N \\in (4,25) \\subseteq \\mathbb{R}$ (assuming real, since unspecified, though more likely to be integer).\n(1) D\n(2) E\n(3) D\n(4) A\n(5) B\n(6) A\n(7) E\n(8) B\n(9) E\n(10) D\n\n3. Is $f(x) = x + 1$ bijective when\n(a) $f : \\mathbb{N} \\mapsto \\mathbb{N}$ ?\n\n$f$ can never be surjective. $0 \\in \\mathbb{N} \\implies \\forall x : f(x) \\neq 0$. Similarly, $min(\\mathbb{N}) = 1 \\implies \\forall x : f(x) \\neq 1$. Thus $f$ is not bijective with this domain and codomain.\n\n(b) $f : \\mathbb{Z} \\mapsto \\mathbb{Z}$ ?\n\nThe argument above doesn't hold over $\\mathbb{Z}$ ; in fact, $f$ is surjective here. It is also injective, since any $\\forall x \\in \\mathbb{Z} : f(x) \\in \\mathbb{Z}$. Thus $f$ is bijective.\n\n4. Properties of floor and ceiling.\nTruthy: (a), (b), (c), (d), (e)\n\n5. $f(4n)$ (and examples)\n(a) $f(4n) = \\log_2(4n) = \\log_2(4) + \\log_2(n) = 2 + f(n)$\nE.g. height of a binary tree of $n$ elements grows like $\\Theta(\\log_2 n)$\n(b) $f(4n) = \\sqrt{4n} = 2\\sqrt{n} = 2 \\cdot f(n)$\nE.g. efficient primality testing of $n$ often is $\\Theta(\\sqrt{n})$\n(c) $f(4n) = 4n = 4 \\cdot f(n)$\nE.g. linear search is $\\Theta(n)$\n(d) cf. worksheet\n(e) $f(4n) = (4n)^2 = 16n^2 = 16 \\cdot f(n)$\nE.g. bubble sort is $\\Theta(n^2)$ ; so is the cartesian product $A \\times A, \\mid A \\mid = n$\n(f) $f(4n) = (4n)^3 = 64n^3 = 64 \\cdot f(n)$\nE.g. naïve search for the precise element $(a,b,c) \\in A \\times B \\times C$ via iterating through all such tuples is $\\Theta(n^3)$\n(g) $f(4n) = 2^{4n} = 2^{n+n+n+n} = 2^n2^n2^n2^n = f(n) \\cdot f(n) \\cdot f(n) \\cdot f(n) = \\prod_{i=1}^4 f(n)$\nE.g. a complete decision tree for a game in which a player selects one of two options at each turn and each option leads to a new state; if the player makes $n$ decisions, the total possible number of states $\\Theta(2^n)$\n(h) $f(4n) = (4n)! = (4n) \\cdot (4n - 1) \\cdot \\cdots \\cdot n! = \\frac{(4n)!}{f(n)} \\cdot f(n) = f(n) \\cdot \\prod_{i=n+1}^{4n} i$\nE.g. computation of the binomial coefficient $\\binom{n}{k}$ using the definition $\\frac{n!}{k!(n-k)!}$ is clearly $\\Theta(n!)$ (assuming $n \\ge k$)\n(i) $f(4n) = (4n)^{4n} = (4)^{4n}n^{4n} = 256^nn^4 \\cdot f(n)$\nE.g. the cardinality of the set of functions from $R$ to $S$ where each of $R,S$ has cardinality $n$\n\n6. Calculate $R_n = \\sum_{i = 0}^n r^i$ using $R_n - r R_n$\nAs in class, if we align similar terms of $R_n = 1 + r + r^2 \\cdots$ and $r R_n = r + r^2 \\cdots$, we see that $R_n - r R_n = R_n (1 - r) = 1 - r^{n+1}$.\nThus $R_n = \\frac{1 - r^{n+1}}{1 - r}$\n\n7. Binomial coefficients $\\binom{n}{k}$\n(a) $\\binom{n}{0} = \\binom{n}{n} = 1$\n(b) $\\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$\nThis is a variation of Pascal's Identity, for which I provide a combinatoric proof below by counting sets.\n$\\binom{n}{k}$ counts the $k$-combinations of a set $S$ of $n$ elements.\nSuppose we have $S$ such that $\\mid S \\mid = n$. Further, let $a \\in S$, and $T = S - \\{a\\}$.\n    Then note that there are $\\binom{n}{k}$ subsets of $S$ containing $k$ elements.\n    Each of these subsets $S_i$ falls into one of two cases:\n    Case 1) $a \\in S_i$\n        Then $\\mid S_i - \\{a\\} \\mid = k-1$, and so there are $\\binom{n-1}{k-1}$ $k-1$-subsets of $T$. There are thus $\\binom{n-1}{k-1}$ $k$-subsets of $S$ containing $a$.\n    Case 2) $a \\not\\in S_i$\n        There are $\\binom{n-1}{k}$ $k$-subsets of $T$, so there are $\\binom{n-1}{k}$ subsets of $S$ not containing $a$.\n        \n    These cases together count the number of subsets of $S$, so the equality holds.\n(c) Some examples:\n    Choose $a = b = 1$; then $(1+1)^n = \\sum_{k=0}^n \\binom{n}{k} 1^k 1^{n-k} = \\sum_{k=0}^n \\binom{n}{k} = 2^n$\n    Choose $a = -b = -1$; then $((-1) + 1)^n = \\sum_{k=0}^n \\binom{n}{k} (-1)^k 1^{n-k} = \\sum_{k=0}^n \\binom{n}{k} (-1)^k = 0$\n    Choose $a = 1, b = 2$; then $(1 + 2)^n = \\sum_{k=0}^n \\binom{n}{k} 1^{n-k} 2^k = \\sum_{k=0}^n \\binom{n}{k} 2^k = 3^n$\n    \n8. Permutations.\nConditions repeated for clarity:\nIf $a_1 \\dots a_m$ and $b_1 \\dots b_n$ are permutations of each other, then:\n(a) $m=n$\n(b) $\\forall i \\in [1 \\dots m], \\exists j \\in [1 \\dots n] : a_i = b_j$\n(c) $\\forall j \\in [1 \\dots n], \\exists i \\in [1 \\dots m] : a_i = b_j$\n\nWe seek two sequences $A,B$ that are not permutations of each other but satisfy (a,b,c).\n\nWe exploit repetitions.\nTake $A = 001, B=011$. These are clearly not permutations of each other (though they are both sorted). (a) is satisfied because they have the same length, and (b,c) are satisfied because for any element in either $A,B$ we can find an element in $B,A$ such that the two are equal.\n\n9. More permutations\n(a) \"Comes from\" permutation $f_1 \\dots f_n$ tracked by insertion sort.\n\nThe original insertion sort variant states that at the beginning of the for loop (pseudo code below), $A[1 \\dots j-1] = sorted(A[1 \\dots j-1])$."
    },
    {
      "type": "code",
      "language": "python",
      "data": "ins_sort(A):\n    for j = 2 to length(A):\n        key = A[j]\n        i = j - 1\n        while i > 0 and A[i] > key:\n            A[i + 1] = A[i]\n            i--\n        A[i + 1] = key"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "We wish to modify insertion sort to produce $F = f_1 \\dots f_n$ as defined in the problem. That is, the new invariant is that $A[f_1 \\dots f_{j-1}] = sorted(A[1 \\dots j-1])$.\n\nThe algorithm essentially initializes $F = 1 \\dots n$ (assuming that $A$ has length $n$). We perform the modifications on $F$ rather than $A$, but compare elements of $A$ using the computed indices in $F$. Note that for 0-indexed arrays, the boundary condition needs updated."
    },
    {
      "type": "code",
      "language": "python",
      "data": "ins_sort_indices(A):\n    F = [1 ... length(A)]\n    for j = 2 to length(A):\n        key = A[F[j]]\n        i = j-1\n        while i > 0 and A[F[i]] > key:\n            F[i+1] = F[i]\n            i = i-1\n        F[i+1] = j\n    return F"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "Correctness can be proven as follows.\n\nInitialization: at $j=2$, the list $A[f_1 \\dots f_1] = A[f_1] = A[1]$ is trivially sorted.\n\nMaintenance: the inner loop performs the same search as that of insertion sort (the position $i$ such that $A[i] \\le key$); however, as stated, we keep track of $A[i]$ via $A[F[i]]$. That is, $F$ is a view onto $A$ that is (partially) sorted. We thus shift the indices $ f_{j-1} \\dots f_{i+1} $ in $F$ right by one position. The new position of the key, $j$, is then placed at $F[i+1]$ such that $A[F[i]] \\le A[F[i+1]] \\le \\dots \\le A[F[j]]$ and the invariant is restored.\n\nTermination: at the end, $j = n+1$ and we have produced the correct result (as a quick test implementation shows).\n\n(b) \"Goes to\" permutation $t_1 \\dots t_n$ computed from the \"comes from\" permutation.\n\nWe seek $T$ such that $A[F] = B, B[T] = A$, and thus $A[F][T] = A[F[T]] = A$ (here I have seriously abused the notation, but the meaning should be clear).\nBut further note that if $I$ is the \"identity\" $[1 \\dots n]$, then we seek $T : F[T] = T[F] = I$. The algorithm is then a simple computation of this fact:"
    },
    {
      "type": "code",
      "language": "python",
      "data": "T(F):\n    T = [1 ... length(F)]\n    for i = 1 to length(F):\n        f = F[i]\n        T[f] = i # equivalently, T[F[i]] = i, a condition on T\n    return T"
    },
    {
      "type": "latex",
      "language": "latex",
      "data": "Invariant: at the start of each for loop, $\\forall j \\lt i : T[F[j]] = j$\nThe proof is rather trivial and I do not include it here.\n\n10. CLRS p. 41 2-4 Inversions\nLet $A[1 \\dots n]$ be an array of $n$ distinct numbers. If $i \\lt j$ and $A[i] \\gt A[j]$, then the pair $(i,j)$ is called an inversion of $A$.\n\n(a) List the five inversions of the array $\\langle 2,3,8,6,1 \\rangle$\nSolution: $\\{(1,5), (2,5), (3,4), (3,5), (4,5)\\}$\n\n(b) What array with elements from the set $\\{1 \\dots n\\}$ has the most inversions? How many does it have?\nSolution: $A = [n, \\dots, 1]$ has the most inversions at $(n-1) + (n-2) + (n-3) + \\dots + 1 = \\sum_{i=1}^{n-1} i = \\frac{n(n-1)}{2}$, since the first element $n$ is greater than the following $n-1$ elements, &c.\n\n(c) What is the relationship between the running time of insertion sort and the nubmer of inversions in the input array? Justify.\nSolution: Since the algorithm for insertion sort corrects each inversion it finds, and the number of inversions is $\\Theta(n^2)$ is also the runtime for insertion sort, we can say they are approximately (if not exactly) equivalent.\n\n(d) Give an algorithm that determines the number of inversions in any permutation on $n$ elements in $\\Theta(n \\lg n)$ worst-case time. Hint: Modify merge sort.\n\nThe idea is to count the number of inversions being corrected during merge sort. Note that the brunt of the work is done in merge, which is also where the \"swaps\" are being done.\nAn inversion is corrected whenever an element from the right array is pulled and there are still elements in the left array (which are, by definition, greater than the element being pulled, and thus each counts for an inversion). Then the number of inversions from pulling $r \\in R$ is $\\mid L' \\mid$ where $L'$ consists only of elements in $L$ not yet merged into the result. We sum the consecutive results to compute the total.\n\nWe don't change the essence of merge sort, other to add a few arithmetic operations in merge. Thus the runtime is asymptotically unchanged."
    },
    {
      "type": "code",
      "language": "python",
      "data": "merge(A,p,q,r):\n    inversions = 0\n    left = n1 = q - p + 1\n    n2 = r - q\n    L = array[1 ... n1 + 1]\n    R = array[1 ... n2 + 1]\n    for i = 1 to n1:\n        L[i] = A[p + i - 1]\n    for i = 1 to n2:\n        R[i] = A[q + j]\n    L[n1 + 1] = ∞\n    R[n2 + 1] = ∞\n    i = j = 1\n    for k = p to r:\n        if L[i] <= R[j]:\n            A[k] = L[i]\n            i = i + 1\n            left = left - 1\n        else:\n            A[k] = R[j]\n            inversions = inversions + left\n    return inversions\n    \ninversion_count(A,p,r):\n    if p < r:\n        q = floor((p+r)/2)\n        return inversion_count(A,p,q) +\n                inversion_count(A,q+1,r) + \n                merge(A,p,q,r)\n    return 0"
    }
  ]
}