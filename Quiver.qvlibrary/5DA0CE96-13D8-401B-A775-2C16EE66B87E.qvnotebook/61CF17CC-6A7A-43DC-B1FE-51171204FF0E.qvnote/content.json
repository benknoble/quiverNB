{
  "title": "28 August // Lecture 3",
  "cells": [
    {
      "type": "markdown",
      "data": "# Performance\n\n### Definitions\n\n*Latency*: Time from input to corresponding output\n*Throughput*: Results produced per unit time\n\n## Design Tradeoffs\n\n- More resources to one task takes away from others\n- Frontloading the task takes more memory\n- &c.\n\nPerformance is rarely the sole factor\n- Cost\n- Energy/power consumption (replaced more often, because of heat)\n\n### Common Compound Metrics\n\nPerformance/Cost\nPerformance/Power\nWork/Energy\n\n## Execution Time\n\nElapsed Time/Wall Clock Time\n- Counts everything (disk/memory access, I/O, &c.)\n- Includes impact of other programs\n- Useful, but often not good for comparison\n\nCPU time\n- Does not include I/O or time spent running other programs\n- Can be broken up into system time, user time\n\nUser time (our focus)\n- time spent executing actual instructions of our program\n\n### Defining Performance\n\nFor some program on machine $x$\n$P_x = \\frac{exec}{t}$\nThis is $\\frac{1}{t}$ for one execution\n\nRelative performance\n$\\frac{P_x}{P_y}$\n$x$ is $n$ times faster than $y$\n\n## CPU Time & Clocking\n\n- Operation of digital hardware governed by a constant-rate clock (ticks)\n- Clock period: duration of a clock cycle\n- $250ps = 0.25ns = 250 \\cdot 10^{-12}s$\n- Clock frequency (rate): cycles per second\n  - $\\frac{1}{0.25ns} = 4GHz$\n\nData is read and computed in between ticks; stored at ticks\n\n### Program Clock Cycles\n\nNewer generation of same processor often has the same cycle count, but different clock speed\n\nClcok \"ticks\" indicate when machine state changes\n\nSimple relation\n$t_{cpu} = cycles \\cdot t_{cycle} = \\frac{cycles}{rate}$"
    }
  ]
}