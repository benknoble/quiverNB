{
  "title": "18 September // Lecture 9",
  "cells": [
    {
      "type": "markdown",
      "data": "Program counter, program execution, interaction between Memory, Control Unit, Data Path\n\n# ISA\n\n- Part of arch that defines native data types, instructions, registers, addressing modes, memory arch, interrupt/exception handling, and external I/O\n- Includes opcode spec, and the native commands implemented by a particular processor\n\n## Encoding ISA\n\nInteresting choices: performances, compactness, programmability\n\nComplexity\n- How many different instructions? What level operations?\n- Reduced Instruction Set Computer (RISC) philosophy: simple instructions, optimized for speed\n\nUniformity\n- Should they be the same size?\n- Take the same time to execute?\n- Trend favors uniformity (simple, speed, cost/power) (RISC)\n\nMix of Engineering & Art (trial)\nuse MIPS as a representative\n\n### MIPS\n\nEach register is a word\n32 bit words (4 bytes)\nSo each address is at an offset of 4, starting from 0\n\nExecution loop\n- fetch `Mem[PC]`\n- `PC += 4`\n- execute instruction (could change `PC`)\n\nLast two bits of `PC` are always $00$\n\nEach instruction is broken up into pieces (see reference, textbook for which component is which thing)\n\nWe need to address both by byte and word, hence numbering of instruction addresses by offset (LSB)\n\n### Data\n\nByte (8 bit chunk)\nShort (16 bit) always even location\nWord (32 bit) always location divisible by word length\nLong/double (64 bit) always location divisble by $2 \\times$ word length\n\n### Registers\n\n32 named registers\nOperands of all instructions are registers\n- This means you must load the values into a register from memory, compute the result, and then store that back in memory\n \nGoing back and forth from memory to a register is expensive\nSo keep in registers as much as possible!\n\n**Special conventions**\n2 have specific \"side effects\"\n- `$0` always has 0\n \n4 registers dedicated to specifc tasks (procedure calls, stack pointer, &c.)\n26 available for general use, but constrained by convention\n\n### Instruction format\n\nSingle 32 bit word\nFields\n- 6-bit OPCODE\n- up to 3 5-bit OPERANDs\n- embedded constants (immediate, literal)\n  - can be 16-bit, 5-bit, or 26-bit\n  \nR format: `OP S1 S2 D shamt func`\nI format: `OP S D C` (16-bit C)\nJ format: `OP C` (26-bit C)\n\n### Some operations\n\n`op = 0x00` means ALU function\n`func = 0x20` means add (`100000`)\n`S1,S2,D` contain binary register numbers"
    }
  ]
}