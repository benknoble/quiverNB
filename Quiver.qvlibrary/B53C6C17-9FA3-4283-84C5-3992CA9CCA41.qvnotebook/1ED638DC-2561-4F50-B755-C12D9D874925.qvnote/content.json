{
  "title": "5 April // Lecture 20",
  "cells": [
    {
      "type": "markdown",
      "data": "PollEv\n\n> Q: The strongly connected digraph shown is (not shown)\n> A: Neither a tree nor acyclic\n\n> Q: The digraph shown represents a finite state machine (FSM), with starting state A. Which of he following best describes the strings of characters that the FSM generates when executed? (Picture)\n> A: All strings of 1 or more \"b\" chars ending or beginning in \"aa\"\n\n> Q: True or False: If a directed graph is cyclic then it is strongly connected\n> A: False. Easy counter-example, however the converse *is* true\n\n> Q: Let's build a graph with a vertex for every person in the USA. We create an (undirected) edge between each two persons that know each other. This graph is...\n> A: Sparse\n\n> Q: Let's build a graph with a vertex for every state in the USA. We create an (undirected) edge between two vertices if it is possible to fly from one state to the other in 3 hops/flights or fewer. This graph is...\n> A: Dense\n\n> Q: If you are told that the FooDeeBar algorithm for directed graphs is linear, which of the following best gives the worst case time complexity?\n> A: $O\\left(\\lvert V\\rvert + \\lvert E\\rvert\\right)$\n\n> Q: If we implement a directed graph with an adjacency matrix, which of the following best describes the worst case space use?\n> A: $O\\left({\\lvert V\\rvert}^2\\right)$\n\n> Q: If we implement a directed graph with adjacency lists, which of the following best describes the worst case space use?\n> A: $O\\left(\\lvert V\\rvert + \\lvert E\\rvert\\right)$\n\n# Graph Algorithms\n## Topo(logical) Sort\n\nComputed for a DAG $G$\nOrdering of *all* vertices $v_i \\in V$ in the graph $G$ such that $(u,v) \\in E \\implies u \\lt v$, that is $u$ precedes $v$ in the sequence\n\nEvery DAG has at least 1; some have more.\nIf there is a cycle, there exists none.\n\nWe suspect a relation between the degree of in-edges and out-edges...\n\n### Properties\n\n- If all vertices have both in-edges and out-edges, there is no topo sort\n- Necessary: if there exists a Topo Sort on $G$, then at least one node and no in-edge and one with no out-edge exists (Not sufficient)\n\n### Algorithm for Finding a Topo Sort\n\nWant to do it in linear time if we can\n\nDef: In-degree of vertex $b$\n- number of edges $(a,b) \\in E$ for distinct $a$\n- number of edges \"coming into\" $b$\n- number of vertices that $b$ is adjacent to\n\nAssume $G=(V,E)$ is build using adjacency list with precomputed in-degree.\n\n1. Any nodes with in-degree 0? If no, then *cycle exists*, `exit`\n2. Pick any node $v$ with in-degree 0. Put $v$ in $TS$\n3. Decrement in-degree of any node $w$ where $(v,w) \\in E$ (effectively remotve v and its out-edges from graphs)\n    - This is destructive. An alternative would be to keep an additional map $M : node \\to in-degree$ that keeps track of pseudo-in-degrees, but does not provide quick searching for which node has in-degree 0\n4. Repeat (1). If there are multiple options, the pick is arbitrary.\n5. If there are no nodes left, `return TS`\n\nAnalysis: handles a each node only once, so its $O\\left(\\lvert V\\rvert + \\lvert E\\rvert\\right)$ **iff** handling a node is $O(1)$ and finding the next node with in-degree 0 is $O(1)$.\n\nHow do we handle finding the next node with in-degree 0?\nAdd a Queue!\nPut each vertex with in-degree 0 into $Q$\nWhen you need the next node with in-degree 0, dequeue\nWhen you take a node out and recompute the nodes, enqueue any that are made to have in-degree 0"
    }
  ]
}