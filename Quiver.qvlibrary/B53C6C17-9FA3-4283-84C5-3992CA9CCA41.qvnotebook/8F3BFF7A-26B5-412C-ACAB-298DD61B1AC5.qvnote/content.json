{
  "title": "22 February // Lecture 12",
  "cells": [
    {
      "type": "markdown",
      "data": "PollEverywhere\n\n> Q: Consider implementing a PrQUE with a BST that somehow guarantees average performance on all operations (not worst case). What is the worst case time complexity of the \"front\" operation on such a PrQUE with $n$ items in it?\n> A: $O(\\log n)$. We are guaranteed average performance, and PrQUE's front is a BST's findMin.\n\n> Q: Which statement is true for the figure shown? (see diagram on PollEv)\n> A: This is not a minimum binary heap because, though it has the heap structure property, it violates the heap order property.\n\n> Q: Which statement is true for the figure shown? (see diagram on PollEv)\n> A: This is not a minimum binary heap because, though it has the heap order property, it violates the heap structure property.\n\n> Q: Heap, or NO Heap ? (see diagram on PollEv)\n> A: NO Heap (YES struct, NO order)\n\n> Q: Heap, or NO Heap ? (see diagram on PollEv)\n> A: Heap (YES struct, YES order)\n\n> Q: Consider this (min) binary heap. We do an insert on an element with priority 10. Click on the node where this element ends up after the insert is complete. (see diagram on PollEv)\n> A: (Have to click in the right spot; it's 3(the root)'s left child)\n\n> Q: Consider this (min) binary heap. We do a \"delMin\" operation. Click on the node where element \"41\" ends up after the delMin is complete. (see diagram on PollEv)\n> A: (Have to click in the right spot; it's 9's right child)\n\n> Q: Consider a binary heap (min heap) with $n$ elements in it. What is the worst case time complexity of the \"getMin\" operation?\n> A: $O(1)$. Simply get the top of the tree/first element in the array \n\n> Q: Consider a binary heap (min heap) with $n$ elements in it. What is the worst case time complexity of the \"deleteMin\" operation?\n> A: $O(\\log n)$\n\n###Binary Heap\nRemarkably, insert is $O(1)$ on average!\n\nThis is because the bottom two layers have most of the nodes in the tree (between $\\frac 1 2$ and $\\frac 3 4$ ish)\nThis means most of the time insert will usually only have to bubble a few times\n\n**Make a Binary Heap of $n$ Elements**\nWe *could* simply do $n$ inserts, for complexity $O(n\\log n)$ in the worst-case\nBut we can do better. We can get $O(n)$\nHow?\n- We require that we already have all $n$ elements somewhere in memory\n- We first guarantee the structural property; load up the heap array in any order from slot $1$ to last ($O(n)$)\n(optionally, we can move an element from slot $0$ to the last slot for $O(1)$, but that's an implementation detail)\n- We finally guarantee the order property; start with the parent of the last node and bubble down as needed; repeat this process by moving up the array towards the root ($O(n)$)\n\nThis makes heapsort as good as BST.\n\nSome important/useful private methods:\n- bubble up\n- bubble down\n- left child index/left child\n- right child index/right child\n- parent index/parent\n- is in heap\nNotice that `size` is equivalent to position of the next empty slot `last` $-1$!"
    }
  ]
}