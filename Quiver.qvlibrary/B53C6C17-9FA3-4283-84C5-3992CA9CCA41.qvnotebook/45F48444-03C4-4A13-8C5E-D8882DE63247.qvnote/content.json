{
  "title": "7 April // Lecture 21",
  "cells": [
    {
      "type": "markdown",
      "data": "PollEv\n\n> Q: For the digraph shown, which of the following is a valid topological sort? [refs diagram]\n> A: 1,2,5,4,7,8,3,6\n\n> Q: For the digraph shown, which of the following is a valid topological sort? [refs diagram]\n> A: None of the options listed\n\n> Q: True or False: Consider a digraph G that is a tree. G has no topo sort.\n> A: False\n\n> Q: True or False: Consider a digraph G that is a tree. G has at least two different topo sorts.\n> A: True for most graphs, but for small ones (one or two nodes) false.\n\n> Q: True or False: Consider a digraph G that is a tree. G has as many different topo sorts as it has leaves.\n> A: True; the ordering of the leaves in the final topo sort is arbitrary! There may of course be more (the ordering in the next level up is somewhat arbitrary assuming all the other nodes above it have been put in the sort), but there will be at least as many as there are leaves.\n\n# Topo Sort (continued)\n\nTalking about using a queue to find nodes with in-degree 0\n\nTopo sort is $O\\left(\\lvert V \\rvert + \\lvert E \\rvert\\right)$ *if* everything goes according to plan\n\n# Minimum Spanning Tree\nundirected graph $G=(V,E)$\nSpanning tree $ST$ of $G$:\n- is a tree\n- formed using edges $\\in E$\n- all vertices $\\in V$ appear in $ST$\n\nMinimum Spanning Tree $MST$ of $G$ is a \n- spanning tree\n- minimized total edge weight\n\n## Properties\nMay be more than one $MST$\nFor unweighted graphs, every $ST$ is also an $MST$\nIf every edge has a different unique weight, there is exactly $1$ $MST$\n\nWhy do we care?\nLaying wire (lay as little as possible)\n\n### Kruskal's Algorithm\nGreedy Algorithm\n- picking local best at each step gives global best solution\n\nBuilds forest, merges the trees into one\n- Start with all nodes, no edges (initial forest)\n- Select edges in order of smallest weight\n- Stop when all vertices have been included\n- Reject an edge if it creates a cycle\n\nCycle detection: efficient way to do it involves making sure we connect to separate forests (fast union of sets)\n\nFinding smallest edge weights:\n- Could sort edges by edge weights; $O\\left(\\lvert E \\rvert \\log \\lvert E \\rvert\\right)$ to sort and retrieve\n- Priority Queue and do a findMin; $O\\left(\\lvert E \\rvert +  \\log \\lvert E \\rvert\\right) = O\\left(\\lvert E \\rvert\\right)$ to build and retrieve\n\n### Prim's Algorithm\nGreedy\n- Start empty tree $T$\n- Pick a node $n$, add to $T$\n- Add edge with smallest weight out of $n$ to $T$\n- Reject cycles\n- Repeat until all vertices added"
    }
  ]
}