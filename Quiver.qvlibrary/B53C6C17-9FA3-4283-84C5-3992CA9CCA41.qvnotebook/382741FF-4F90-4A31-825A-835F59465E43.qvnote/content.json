{
  "title": "19 April // Lecture 24",
  "cells": [
    {
      "type": "markdown",
      "data": "Poll Ev\n\n> Q: [refs diagram] Does this graph have an Euler Circuit?\n> A: No; it had vertices with odd degree\n\n> Q: [refs same diagram] Does this graph have an Euler Path?\n> A: Yes; it has exactly 2 vertices with odd degree, so must start on one and end on the other\n\n> Q: [same diagram] Does this graph have a Hamiltonian Circuit?\n> A: Yes; I was able to find one. ($H\\to F\\to G\\to E\\to D\\to X\\to C\\to B\\to A\\to H$)\n\n> Q: [same diagram] Does this graph have a Hamiltonian Path that is *not* a Circuit?\n> A: Yes; I was able to find one. ($A\\to H\\to F\\to G\\to E\\to D\\to X\\to B\\to C$)\n\n> Q: [new diagram] Does this graph have a Hamiltonian Path that is *not* a Circuit?\n> A: Yes; I was able to find one. ($H\\to B\\to D\\to G\\to A\\to X\\to E\\to C\\to F$)\n\n> Q: [same diagram] Does this graph have a Hamiltonian Circuit?\n> A: No. There are two \"section\" connected by $X$; if we complete one, we cannot return to it after passing $X$ without returning through $X$. We have a bridge.\n\n> Q: [new diagram] Does this graph have a Hamiltonian Path?\n> A: No. It's a tree (and thus acyclic).\n\n> Q: True or False: Every tree has no Hamiltonian Path.\n> A: False. Consider a single node, or a linked list, or something similar.\n\n# Sorting\nEfficiency is critical for large data sets (e.g., Ebay)\n\n### Bubble Sort\nGold standard for badness ($O(n^2)$)\n*Swap-based*\n*In-place* (does not use another temporary array of size $n$)\n*Stable* (preserves original order for items of the same value)\n\n*N.B.* For swap-based, fastest you can do is $O(n\\log n)$. If we use more memory (buckets, not swaps), we can actually reach $O(n)$\n\n### Insertion Sort\nSwap-based\n$O(n^2)$\nIn-place\nStable\nAdvantageous over Bubble (esp. for small data sets)\nTake each item and compare with next neighbor (if out of order, take the neighbor and insert it in the array where it belongs--requires shifting the other elements)\n\n### Selection Sort\nSwap-based\n$O(n^2)$\nIn-place\nUnstable\nPass through array $n$ times\n$\\implies$ for each pass $i$, find smallest item in array and swap it with slot $i$\n\n### Heap Sort\nMin Heap\n$O(n\\log n)$\nnot in-place (the way we discussed in class; there is in fact a way to make it in-place)\nnot stable\nBuild heap, delMin $n$ times back into array\nAlso requires $O(n)$ extra memory (if not in-place)\nIn-place technique:\n1. Heap build\n2. After a delMin where everything is shuffled around, use the back end of the array to store the results (stick the first in the last, the second in the second to last). This gives a reverse order\n\n### Merge Sort\nDivide and conquer\n$O(n\\log n)$\nStable\ncan be in-place, usually done with extra arrays\nHalve list repeatedly until single elements ($O(\\log n)$)\nMerge neighboring lists repeatedly (1 to 2, 2 to 4, &c.) ($O(2n)$)\n\n### Quick Sort\n$O(n\\log n)$ *average* case\n$O(n^2)$ *worst* case, but this is rare\nin-place\nnot stable\nLook at videos for how it works"
    }
  ]
}