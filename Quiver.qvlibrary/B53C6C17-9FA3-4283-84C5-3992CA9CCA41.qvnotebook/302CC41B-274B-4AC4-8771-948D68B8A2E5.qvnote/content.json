{
  "title": "29 March // Lecture 18",
  "cells": [
    {
      "type": "markdown",
      "data": "Poll Ev\n\n> Q: In a hash table the load \"lambda\" is found by ...\n> A: # elts / # total array slots\n\n> Q: In a hash table where we handle collisions via chaining (lists), the load \"lambda\" tells us ...\n> A: Average chain length\n\n> Q: TRUE or FALSE: In a hash table where we handle collisions via chaining (lists), when the load \"lambda\" reaches 1 the table is full and we can store no more keys (assuming we don't extend the table).\n> A: We can add more keys, but eventually we lose out substantially on performance, so we consider it full in that sense.\n\n> Q: TRUE or FALSE: In a hash table where we handle collisions via probing, when the load \"lambda\" reaches 1 the table is full and we can store no more keys (assuming we don't extend the table).\n> A: True; we have exhausted the possible slots useable for probing.\n\n> Q: In a hash table, using linear probing for collisions, with N array slots and load \"lambda\" of .5, which of the following gives the best description of the worst case time complexity for the add operation?\n> A: $O(n \\times \\lambda)$\n\n> Q: In a hash table, using chaining for collisions, with N array slots and load \"lambda\" of .5, which of the following gives the best description of the worst case time complexity for the add operation?\n> A: $O(1)$\n\n> Q: Why might we want a TreeMAP instead of a HashMAP?\n> A: \"Something else...\" The tree retains ordering information, which we may want to use\n\n> Q: TRUE or FALSE: Hashing... a hash table... can help us sort a list of $n$ items faster (so far we have $O(n \\log n)$ methods).\n> A: False. We lose ordering information in a hash table. However if we hash integers using the identity function than the table is already sorted (unfortunately very case-specific) and this is $O(size_{table})$. Similar to bucket sorting, which we find is $O(n)$. Overall, we don't really get much out of it. We discussed an approach that uses more table space by using more and more letters from the strings to keep the lists short.\n\n# Graphs (cont.)\n## Graph Algorithms (cont.) and Properties\n- Cycle-detection...?\n(see last time)\n\n- Connectedness (undirected)\nPath from every vertex to every other vertex\n\n- Connectedness (directed)\n  - Strong connnected: Path from every vertex to every other vertex\n  - Weakly connected: underlying undirected graph is connected\n  \n- Complete Graph\nEdge between any two distinct vertices\n$n$ nodes, $\\frac{n(n-1)}{2}$ edges\n\n- Planar Graph\nAll edges can be drawn on a plane with none crossing\n\n- Bipartite Graph\nNodes are in two disjoint sets (types), and every edge connects different type nodes\nCan consider it like colorable with only two colors and each edge is between the two color collections\n\n## Graph Implementation\nBrief intro to Finite State Machines (and Predicate Transition Nets which are bipartite)\nTalked about modeling with a graph"
    }
  ]
}