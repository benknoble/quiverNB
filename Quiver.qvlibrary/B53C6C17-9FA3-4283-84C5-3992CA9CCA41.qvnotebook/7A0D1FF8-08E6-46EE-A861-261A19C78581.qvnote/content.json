{
  "title": "25 January // Lecture 4",
  "cells": [
    {
      "type": "markdown",
      "data": "*Assignment 1 available* (Due 6 Feb.)\n\n#Lists, Stacks, and Queues (cont.)\n##Lists\nTwo types\n1. Arrays\n2. Linked Lists (singly or doubly)\n\nArrays have to move things around, make room for new elements to insert and remove in the list.\nThis makes insert and remove $O(n)$, which is acceptable if you're not performing a lot of inserts and removals. But for large data sets it is relatively inefficient.\nHowever, arrays are good for constant-time acessing $\\left(O(1)\\right)$. Array-based Lists are good for unchanging, continuously accessed lists.\nFinding elements requires scanning the entire array, which is $O(n)$.\nDetermining whether a list is empty or how many elements it contains is constant time $O(1)$ as well.\n\n###Linked Lists\nImplement Lists using linked cells\n\nNode structure: each node contains an element of data and a reference to the next Node in the List.\nThere is typically a 'head' reference that always refers to the first Node.\n(Generally, the above describes a singly-linked list).\n - Insert is $O(n)$ (Simply change the references to point to the right spot, which is constant time, but requires finding the right spot)\n - Remove $O(n)$ (Same as insert; change the references, but requires a find operation)\n - Get $O(n)$ (Must find the correct position)\n - Find $O(n)$\n - Empty $O(1)$\n - Size $O(1)$ if a counter is kept\nBecause inserting at the beginning of a linked list is incredibly efficient, building up the linked list in the right direction is $O(1)$ constant-time, which is very efficient.\n\n(Can also have doubly-linked lists, where each node points to the previous and next node)"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function myMain() {\n    var list = makeCell(\"alpha\");\n    var cur = list;\n    \n    //the idea of pointers to the next nodes\n    cur.next = makeCell(\"beta\");\n    cur = cur.next;\n    cur.next = makeCell(\"gamma\");\n    cur = cur.next;\n    cur.next = makeCell(\"delta\");\n    cur = cur.next;\n    cur.next = makeCell(\"epsilon\");\n    cur = cur.next;\n    cur.next = makeCell(\"zeta\");\n    cur = cur.next;\n    //list is now\n    //(val: alpha, next: -> (val: beta, next: -> (val: gamma, next: -> (val: delta, next: -> (val: epsilon, next: -> (val: zeta, next: -> null))))))\n    \n    //load up big list\n    var MAX = 40000;\n    var bigList = makeCell(\"start\");\n    var cur = list;\n    for (var n=1; n<MAX; n++) {\n        cur.next = makeCell(randomString(10));\n        cur = cur.next;\n    }\n    \n    //printIter is iterative\n    //printRec is recursive (dangerous for big lists!!)\n}\n\nfunction makeCell(v) {\n    var cell = {\n        val: v,\n        next: null\n    };\n    \n    return cell;\n}\n\nfunction printIter(c) {\n    var cur = c;\n    while (cur!==null) {\n        alert(cur.val);\n        cur = cur.next;\n    }\n}\n\nfunction printRec(c) {\n    if (c!==null) {\n        alert(cur.val);\n        printRec(c.next);\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "Special lists are useful for solving many problems\n\nStack: reversing sequences, balancing parens\nQueue: fairness, maintain order of arrival\n\n###Stack\nStack is built up (inserted/pushed) and torn down (removed/popped) in only one direction: the end\nPerfect for list!\nPush is now $O(1)$ (push at the end for arrays, beginning for linked list)\nTop is now $O(1)$ (get for arrays is constant time, getting head for linked list is constant time)\n\n###Queue\nQueue enqueues on one end and dequeues on the other\n\nEnqueue is $O(1)$ for linked list (insert at the end: requires a reference 'tail' to the end of the list in the implementation)\nDequeue is $O(1)$ for linked list (remove at the beginning)\n\nEnqueue is $O(1)$ for array (store one end)\nDequeue is $O(n)$ for array (remove causes a reshuffle on the array)\n\n###Improved Sort\nUsing a linked list\n1. Create a new linked list\n2. Add each item from the input to the list in the proper place\n3. List is always sorted (insertion sort): $O(n)$ to insert each item, $O(n^2)$ to sort an entire collection of values\nMost efficient on partially sorted or reverse-sorted collections, but worst-case is as above\n\nCan also be thought of as $\\sum _{i=0} ^n i = \\frac {n(n+1)} 2$ which is clearly $O(n^2)$.\nDrawing a graph reveals the exact worst case behaviour to be approximately $\\frac {n^2} 2$, which *is* $O(n^2)$ by definition.\nWe throw away leading constants like $\\frac 1 2$."
    }
  ]
}